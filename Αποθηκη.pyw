#! /usr/bin/env python
#  -*- coding: utf-8 -*-
"""
# GUI module generated by PAGE version 4.26
# http://page.sourceforge.net/
#  in conjunction with Tcl version 8.6
#    Dec 03, 2019 10:58:07 PM EET  platform: Windows 10 NT

# coding=utf-8

Sqlite Γραφικό περιβάλλον με Python3
******************************************************************
** Οι βάσεις πρέπει να έχουν Id ή id ή ID intiger και NOT NULL  **
******************************************************************
**************************************************************************************************************
***********************  ΠΡΟΣΟΧΗ Ο ΤΕΛΕΥΤΑΙΟΣ ΠΙΝΑΚΑΣ ΠΡΕΠΕΙ ΝΑ ΕΙΝΑΙ Η ΠΑΡΑΓΓΕΛΙΕΣ **************************
**************************************************************************************************************

Version V2.0.5   | Νεος πίνακας Πελάτες και δυνατότητα διαγραφη επιλεγμένων παραγγελιών  --------------------31/12/2019

Version V2.0.4   | Δημιουργία Class με βοήθεια απο το Page και αλλαγή απο grid σε place  --------------------9/12/2019

Version V1.0.4   | Χρώματα στα κουμπιά και διόρθωση κάποιων σφαλμάτων στον κωδικα                     | -----30/11/2019

Version V1.0.3   | Δημιουργία πίνακα απο τον χρήστη και δυνατότητα ανοίγματος άλλης βάσης δεδομένων  | -----28/11/2019

Version V1.0.2   | Διόρθωση προσθήκη προϊόντος χωρίς κωδικό στις παραγγελίες               | --------------24/11/2019

Version V1.0.1   | Προσθήκη κουμπί "προσθήκη στις παραγγελίες στο παράθυρο  επεξεργρασίας | --------------24/11/2019

Version V1.0.0   | Προσθήκη πίνακα παραγγελίες και ολα  παίζουν σωστά | ---------------------------------24/11/2019

Version V0.9.6   | Προσθήκη scolledtext και ολα τα χρώματα παίζουν σωστά | ------------------------------23/11/2019

Version V0.9.5   | Προσθήκη χρωμάτων στα MAGENTA CYAN BLACK YELLOW | ------------------------------------22/11/2019

Version V0.9.4   | Fixed log file (layout), fonts και toplevel παράθυρα   | -----------------------------18/11/2019

Version V0.9.3   | ΤΑΞΙΝΟΜΗΣΗ  δουλεύει σωστά  | -----------------------18/11/2019

Version V0.9.2   | Το πρόβλημα με το , λύθηκε | ------------------------17/11/2019

Version V0.9.1   | Dynamic screen sizes |  | Cleaned code | ------------17/11/2019

Version V0.9    -----------------------------------------------------------------------------------------17/11/2019
                1) Προσθήκη τελευταίας τροποποιήσης (ημερομηνία , ώρα και όνομα χρήστη που έκανε την τελευταία αλλαγή)
                2) Το σύνολο το κάνει μόνο του
                3) Ο χρήστης μπορεί να προσθέση κενό προϊόν
                4) Ολοι οι πίνακες εμφανίζονται στο ιδιο πλάτος

Version V0.8.4 Symbol € added to everything Db merged-----------------------------------------------------15/11/2019

Version V0.8.3 Dinamic buttons work well -------------------------------------------------------12/11/2019

Version V0.8.02 Sort added to headers-----------------------------------------------------------11/11/2019

Version v0.8 + Log File added Για το μαγαζί δουλευουν ολα ----------------------------10/11/2019
Στην v0.7  έφτιαχνε συνεχεια frames στο root
ΕΓΙΝΕ ΚΑΘΑΡΣΙΣΜΟΣ ΚΩΔΙΚΑ
ΠΡΕΠΕΙ ΝΑ ΚΑΝΩ ΤΟ ΣΥΝΟΛΟ = TIMI * TEMAXIA

Version v0.7 Για το μαγαζί δουλευουν ολα ----------------------------9/11/2019
ΠΡΕΠΕΙ ΝΑ ΚΑΝΩ ΤΟ ΣΥΝΟΛΟ = TIMI * TEMAXIA

Version Για το μαγαζί                                               8/11/2019
Ολα δουλευουν   να κανω στο Line 103

version v 0.5 Ο χρήστης μπορεί να επιλεξει πίνακα
version v 0.4 Προσθήκη menu
version v 0.3 Η αναζήτηση δουλευει για ολες τις Βάσεις και πινακες

TODO: LIST   ********* ΠΡΕΠΕΙ ΝΑ ΤΑ ΒΑΛΩ ΟΛΛΑ ΣΕ CLASS ΓΙΑ ΝΑ ΠΑΙΞΟΥΝ ΣΩΣΤΑ *******************  Εγινε 9/12/2019
TODO: 0) Επεξεργρασία επιλεγμένου απο το treeview  ΝΑ ΠΕΡΝΕΙ column αντι TONER=? κτλπ.-----------Εγινε 29/10/2019
TODO: 1) ΝΑ ΦΤΙΑΞΩ ΤΟ BACKUP DIRECTORY-----------------------------------------------------------ΕΓΙΝΕ
TODO: 2) ΤΟ TREE NA ΕΜΦΑΝΙΖΕΙ OTI ΒΑΣΗ ΚΑΙ ΝΑ ΕΠΙΛΕΞΩ--να εμφανίζει τους πίνακες-----------------ΕΓΙΝΕ 30/10/2019
TODO: 3) ΝΑ ΒΑΛΩ ΜΕΝΟΥ --------------------------------------------------------------------------Εγινε 1/11/2019
TODO: 4) ο χρήστης να επιλέγει τον πίνακα--------------------------------------------------------Εγινε 6/11/2019
TODO: 5) Ελεγχος αν ο χρήστης εισάγει αλφαριθμητικό ή αριθμό-------------------------------------Εγινε 17/11/2019
TODO: 6) Να βάλω να έχει log αρχείο--------------------------------------------------------------Εγινε 10/11/2019
TODO: 7) Να κάνει αυτόματα υπολογισμό το σύνολο (όταν έχουμε τιμη και τεμάχια) ------------------Εγινε 17/11/2019
TODO: 8) ΠΡΕΠΕΙ ΝΑ ΦΤΙΑΞΩ ΤΟ BACKGROYND STA COLORS ΝΑ ΕΙΝΑΙ ΣΥΜΦΟΝΑ ΜΕ ΤΗΝ ΣΕΙΡΑ ΓΡΙ Ή ΑΣΠΡΟ-----Εγινε 22/11/2019
TODO: 9) ΠΡΕΠΕΙ ΣΤΗΣ ΠΑΡΑΤΗΡΗΣΕΙΣ ΝΑ ΒΑΖΕΙ ΜΟΝΟ ΤΗΝ ΤΕΛΕΥΤΑΙΑ ΤΡΟΠΟΠΟΙΗΣΗ------------------------Εγινε 22/11/2019
TODO: 10) Να βάλω στο μενοu RUN SQL
TODO: 11) Το sort δεν παίζει καλά με τα νούμερα -------------------------------------------------Eγινε 18/11/2019
"""

import sqlite3
import os.path
import tkinter.ttk as ttk
import tkinter as tk
from datetime import datetime
from tkinter import RAISED, PhotoImage, StringVar, messagebox, filedialog, TclError
from tkinter.scrolledtext import ScrolledText
# Για την τελευταια τροποποίηση απο ποιόν χρήστη
import getpass
# Για τα αρχεία log files
import logging, sys

import Αποθηκη_support
import platform

py3 = True

# dbase = "\\\\192.168.1.33\\εγγραφα\\2.  ΑΠΟΘΗΚΗ\\3. ΚΑΙΝΟΥΡΙΑ_ΑΠΟΘΗΚΗ.db"
dbase = "3. ΚΑΙΝΟΥΡΙΑ_ΑΠΟΘΗΚΗ.db"
tables = []
user = getpass.getuser()

# -------------ΔΗΜΗΟΥΡΓΕΙΑ LOG FILE------------------
today = datetime.today().strftime("%d %m %Y")
log_dir = "logs" + "\\" + today + "\\"

if not os.path.exists(log_dir):
    os.makedirs(log_dir)
else:
    pass

log_file_name = "ml_database_log" + datetime.now().strftime("%d %m %Y %H %M %S") + ".log"
log_file = os.path.join(log_dir, log_file_name)

# log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
root_logger = logging.getLogger()
root_logger.setLevel(logging.DEBUG)  # or whatever
handler = logging.FileHandler(log_file, 'w', 'utf-8')  # or whatever
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')  # or whatever
handler.setFormatter(formatter)  # Pass handler as a parameter, not assign
root_logger.addHandler(handler)
sys.stderr.write = root_logger.error
sys.stdout.write = root_logger.info


def get_tables():
    """ Αποκόμιση  πινάκων απο την βάση δεδομένων """

    global tables
    tables = []  # Πρέπει να αδειάσουμε πρώτα την λίστα με τους πίνακες για να κάνουμε νέα σύμφονα με την βάση
    # =======================Ανάγνωριση πίνακα δεδομένων=============
    conn = sqlite3.connect(dbase)
    cursor = conn.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;")
    table_name = cursor.fetchall()
    cursor.close()
    conn.close()
    dont_used_tables = ["sqlite_master", "sqlite_sequence", "sqlite_temp_master"]  # Πινακες που δεν θέλουμε
    for name in table_name:
        if name[0] not in dont_used_tables:
            tables.append(name[0])
            # print("TABLE ", name[0], " ========added to tables line 118")

        else:
            continue
    # print("Γραμμη 136: Πίνακες που βρέθηκαν -->>", tables)
    return tables


def vp_start_gui():
    """
    Starting point when module is the main routine.
    """
    global val, w, root
    root = tk.Tk()
    top = Toplevel1(root)
    Αποθηκη_support.init(root, top)

    def quit_app(event):
        root.destroy()

    root.bind('<Escape>', quit_app)
    root.mainloop()


w = None


def create_Toplevel1(root, *args, **kwargs):
    '''Starting point when module is imported by another program.'''
    global w, w_win, rt
    rt = root
    w = tk.Toplevel(root)
    top = Toplevel1(w)
    Αποθηκη_support.init(w, top, *args, **kwargs)
    return (w, top)


def destroy_Toplevel1():
    global w
    w.destroy()
    w = None


def make_new_table():
    new_table_window = tk.Toplevel()
    # height = int(root.winfo_screenheight() / 2)
    width = int(root.winfo_screenwidth() / 2)
    new_table_window.geometry(str(width) + "x" + "550")
    new_table_window.title("Δημιουργία νέου πίνακα")
    title_label = tk.Label(new_table_window, text="Δημιουργία  πίνακα", font=("Calibri", 15, "bold"), bg="brown",
                           fg="white")
    title_label.grid(columnspan=3, row=0)

    info = """   *****  ΠΡΟΣΟΧΗ *****
                1. Το όνομα του πίνακα δεν μπορεί να ξεκοινάει απο '{}'
                και πρέπει να είναι χωρίς κενό (π.χ. 'ονομα_νεου_πινακα').\n
                2. Τα πεδία πρέπει να είναι όλα διαφορετικά μεταξύ τους!\n
                3. Στο τελευταίο πεδίο θα είναι πάντα η ημερομηνία 
                4. Για να εμφανιστεί ο πίνακας στην πάνω σειρά θα πρέπει :
                να ξεκοινάει το όνομα του με Αγγλικό γράμμα.\n
                5. Για να εμφανιστεί ο πίνακας στην δεύτερη σειρά θα πρέπει 
                να ξεκοινάει το όνομα του με Ελληνικό γράμμα.\n
                6. Για αυτόματους υπολογισμούς (π.χ. σύνολο = τιμή * τεμάχια ) 
                   θα πρέπει να ορίσετε τρία πεδία :  
                 α. ένα πεδίο με όνομα 'ΤΕΜΑΧΙΑ' (Ελληνικά κεφαλαία).  
                 β. ένα πεδίο με όνομα 'ΤΙΜΗ' (Ελληνικά κεφαλαία).
                 γ. ένα πεδίο με όνομα 'ΣΥΝΟΛΟ' (Ελληνικά κεφαλαία).\n
                7. Για να μπορείτε να κάνετε παραγγελίες : 
                   α. Χρειάζεται ενα πεδίο με όνομα 'ΚΩΔΙΚΟΣ' (Ελληνικά κεφαλαία)
                   β. Χρειάζεται ενα πεδίο με όνομα 'ΠΕΡΙΓΡΑΦΗ' (Ελληνικά κεφαλαία)\n
                8. Για να μπορείτε να κάνετε αναζήτηση :
                   α. Χρειάζεται ενα πεδίο με όνομα 'ΠΕΡΙΓΡΑΦΗ' (Ελληνικά κεφαλαία)\n
                9. Για να αλλάξει χρώμα  ο πίνακας πάρτε με τηλ 
            """.format(tables[-1][0])

    info_label = tk.Label(new_table_window, text=info, font=("Calibri", 12), fg="red")
    info_label.grid(column=2, rowspan=11, sticky="e")

    title_name_label = tk.Label(new_table_window, text="Όνομα πίνακα :  ", font=("Calibri", 12, "bold"))
    title_name_label.grid(column=0, row=1)

    table_name = StringVar()
    table_name_entry = tk.Entry(new_table_window, textvariable=table_name, )
    table_name_entry.grid(column=1, row=1, ipady=2)
    table_name_entry.focus()
    fields = []  # Τα πεδία

    for i in range(11):
        title_name_label = tk.Label(new_table_window, text="Πεδίο " + str(i + 1) + " :  ",
                                    font=("Calibri", 12, "bold"))
        title_name_label.grid(column=0, row=i + 2)

        column = StringVar()  #
        table_name_entry = tk.Entry(new_table_window, textvariable=column)
        table_name_entry.grid(column=1, row=i + 2, ipady=2)
        fields.append(column)

    def ad_table_to_db():
        fields_to_add = []
        for field in fields:
            if field.get() != "":
                fields_to_add.append(field.get())
            else:
                pass

        name_of_table = table_name.get()

        # Αν ο νέος πίνακας ξεκοινάει με το γράμμα του τελευταίου πίνακα που είναι ο πίνακας για παραγγελίες
        if name_of_table[0] == tables[-1][0]:
            messagebox.showwarning("Σφάλμα", info)
            new_table_window.destroy()
            return None

        # Αν ο χρήστης δεν ορίσει κανένα πεδίο
        if not fields_to_add:
            messagebox.showwarning("Σφάλμα", "Πρέπει να ορίσεται τουλάχιστον ένα πεδίο")
            new_table_window.destroy()
            return None
        else:  # Αν ο χρήστης ορίσει πεδία να προστεθει το TEXT για να δημιουργίσουμε νέο πίνακα
            fields_to_add = " TEXT,".join(fields_to_add)  # πεδιο1 ΤΕΧΤ , πεδιο2 ΤΕΧΤ Κτλπ.

        if name_of_table in tables:
            messagebox.showwarning("Σφάλμα", "Ο πίνακας {} υπάρχει στους ήδη υπάρχοντες πίνακες {}"
                                   .format(name_of_table, tables))
            new_table_window.destroy()
            return None
        try:
            conn = sqlite3.connect(dbase)
            cursor = conn.cursor()
            # fields_to_add == πεδιο1 ΤΕΧΤ, πεδιο2 ΤΕΧΤ Κτλπ...
            cursor.execute("CREATE TABLE IF NOT EXISTS " + name_of_table +
                           "(ID INTEGER PRIMARY KEY AUTOINCREMENT, " + fields_to_add + ");")
            print("Line 371 Δημιουργία νέου πίνακα {} με πεδία {}".format(name_of_table, fields_to_add))
            conn.commit()
            conn.close()
        except sqlite3.OperationalError as error:
            messagebox.showwarning("Σφάλμα",
                                   "Προσοχή τα πεδία δεν μπορούν να έχουν το ίδιο όνομα \n {}".format(error))
            new_table_window.destroy()
            return None
        messagebox.showinfo('Εγινε προσθήκη Πίνακα', "Ο πίνακας {} δημιουργίθηκε ".format(name_of_table))
        new_table_window.destroy()
        # Επανεκκίνηση προγράμματος
        root.destroy()
        vp_start_gui()
    enter_button = tk.Button(new_table_window, text="Προσθήκη Πίνακα", bg="green", fg="White", bd=8, padx=5, pady=8,
                             command=ad_table_to_db)
    enter_button.grid(column=2, row=12)

    # ΕΞΩΔΟΣ
    def quit_app(event):

        new_table_window.destroy()

    new_table_window.bind('<Escape>', quit_app)


# Κουμπί να ανοιξει το αρχείο (βαση δεδομένων)
def open_file():
    """ Ανοιγμα αρχείου βάσης δεδομένων"""

    global dbase, tables
    # Να σβήσουμε παλιά κουμπιά και tree αν ανοιξουμε αλη βαση δεδομένων

    # print("list_of_frames root.grid.slaves line 78", list_of_frames)
    # for i in list_of_frames:
    #     print(i)
    #     if len(list_of_frames) > 1:
    #         if ".!frame" in str(i):
    #             i.destroy()
    #         elif ".!scrollbar" in str(i):
    #             i.destroy()
    #     else:
    #         # print("list_of_frames root.grid.slaves  after deleted line 129", list_of_frames)
    #         continue
    dbase = filedialog.askopenfilename(initialdir=os.getcwd(), title="Επιλογή βάσης δεδομένων",
                                       filetypes=(("db files", "*.db"), ("all files", "*.*")))
    # dbase = "\\\\192.168.1.33\\εγγραφα\\2.  ΑΠΟΘΗΚΗ\\3. ΚΑΙΝΟΥΡΙΑ_ΑΠΟΘΗΚΗ.db"
    # print("Γραμμή 112: Επιλεγμένη βάση δεδομένων -->>", dbase)
    tables = get_tables()
    root.destroy()
    vp_start_gui()

    return None


# Εμφάνιση πληροφοριών
def get_info():
    messagebox.showinfo("Πληροφορίες", """ 
    Αuthor     : "Jordanis Ntini"
    Copyright  : "Copyright © 2019"
    Credits    : ['Athanasia Tzampazi']
    License    : 'Gpl'
    Version    : '2.0.5'
    Maintainer : "Jordanis Ntini"
    Email      : "ntinisiordanis@gmail.com"
    Status     : 'Development' 
    Language   : Python 3.8
    tkinter    : 8.6
""")


class Toplevel1:
    def __init__(self, top=None):
        """This class configures and populates the toplevel window.
                   top is the toplevel containing window.
        """
        # self.top = root
        top.geometry("1024x700+200+70")
        top.minsize(300, 300)
        top.maxsize(2560, 1080)
        top.resizable(1, 1)
        top.title("Αποθήκη V2.0.5")
        top.configure(background="#C2C0BD")
        top.bind('<F1>', self.add_event)
        top.bind('<F3>', self.double_click)

        self.tables = get_tables()
        self.width_of_tree = top.winfo_screenwidth()
        self.buttons = []  # Για εισαγωγεί κουμπιών [btn1,btn2....]
        self.table = ""  # Mε το πάτιμα του κουμπιου αλλάζει ο πίνακας
        self.headers = []  # Για να περνουμε της επικεφαλίδες καθε πίνακα
        self.images = []  # Εικόνες Κουμιών
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9'  # X11 color: 'gray85'
        _ana1color = '#d9d9d9'  # X11 color: 'gray85'
        _ana2color = '#ececec'  # Closest X11 color: 'gray92'
        self.style = ttk.Style()

        # style.theme_names()-->> ('winnative', 'clam', 'alt', 'default', 'classic', 'vista', 'xpnative')
        self.style.theme_use('vista')

        # Εικονίδιο για resize το παράθυρο
        self.style.configure('TSizegrip', background=_bgcolor)
        self.TSizegrip1 = ttk.Sizegrip(top)
        self.TSizegrip1.place(anchor='se', relx=1.0, rely=1.0)

        # # # Modify the font of the body
        self.style.theme_create("mystyle.Treeview", parent="vista")
        # self.style.configure("mystyle.Treeview.Heading", background="gray", foreground="white", relief="flat")
        self.style.map('mystyle.Treeview', foreground=self.fixed_map('foreground'),
                       background=self.fixed_map('background'))

        # ==================================== Εμφάνηση δεδομένων ==============================================
        self.style.configure("mystyle.Treeview", highlightthickness=1, font=('Calibri', 11))
        self.style.configure("mystyle.Treeview.Heading", font=('Calibri', 12, 'bold'), background="#657b83",
                             foreground="black",
                             relief=[('active', 'groove'), ('pressed', 'sunken')])  # Modify the font of the headings
        self.style.layout("mystyle.Treeview", [('mystyle.Treeview.treearea', {'sticky': 'nswe'})])  # Remove the borders
        self.style.configure("mystyle.Treeview", background="white", rowheight=50)

        # ---------------------------------------Menu-----------------------------------------
        self.menubar = tk.Menu(top, font="TkMenuFont", bg=_bgcolor, fg=_fgcolor)
        # --------------------------------------   MENU   -----------------------------------------
        self.filemenu = tk.Menu(self.menubar, tearoff=0)
        self.filemenu.add_command(label="Ανοιγμα αρχείου", command=open_file)

        self.filemenu.add_command(label="Προσθήκη --> F1", command=self.add_to)
        self.filemenu.add_command(label="Επεξεργασία --> F3", command=self.edit)
        self.filemenu.add_separator()
        self.filemenu.add_command(label="Διαγραφή", command=self.del_from_tree)
        self.filemenu.add_command(label="Εξωδος --> Esc", command=top.quit)
        self.menubar.add_cascade(label="Αρχείο", menu=self.filemenu)

        self.backup_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Αντίγραφο ασφαλείας", menu=self.backup_menu)
        self.backup_menu.add_command(label="Δημιουργία αντίγραφο ασφαλείας!", command=self.backup)

        self.table_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Πίνακες", menu=self.table_menu)
        self.table_menu.add_command(label="Δημιουργία νέου πίνακα", command=make_new_table)

        self.info_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Info", menu=self.info_menu)
        self.info_menu.add_command(label="Πληροφορίες", command=get_info)

        top.configure(menu=self.menubar)

        # --------------------------- Πίνακες - Κουμπιά ------------------------------
        self.xspot = 0.015
        self.yspot = 0.025

        for index, table in enumerate(self.tables):
            if index == 11:
                self.yspot = 0.125  # Υψως
                self.xspot = 0.015  # Πλάτος
            self.btn = tk.Button(top)
            self.btn.place(relx=self.xspot, rely=self.yspot, height=78, width=120)
            self.btn.configure(activebackground="#ececec")
            self.btn.configure(activeforeground="#000000")
            self.btn.configure(background="#657b83")
            self.btn.configure(disabledforeground="#a3a3a3")
            self.btn.configure(foreground="white")
            self.btn.configure(highlightbackground="#d9d9d9")
            self.btn.configure(highlightcolor="black")
            self.btn.configure(pady="2")
            self.btn.configure(padx="2")
            self.btn.configure(text=table)
            self.btn.configure(relief=RAISED)
            self.btn.configure(bd=2)
            self.btn.configure(font=('Calibri', '10', 'bold'))
            try:
                self.img = PhotoImage(file="icons/" + table + ".png")
                self.btn.configure(image=self.img)
                self.images.append(self.img)
                # self.btn.configure(compound='left')
            except:
                self.btn.configure(image="")
                pass

            self.btn.configure(command=lambda x=table: [self.change_color(x), self.update_view(x)])
            self.xspot += 0.080
            self.buttons.append(self.btn)

        self.yspot += 0.110
        self.search_data = StringVar()

        # ---------------------Πεδίο Αναζήτησης ----------------------
        self.search_entry = tk.Entry(top, textvariable=self.search_data)
        self.search_entry.place(relx=0.315, rely=self.yspot, height=24, relwidth=0.240)
        self.search_entry.configure(background="white")
        self.search_entry.configure(disabledforeground="#a3a3a3")
        self.search_entry.configure(font="TkFixedFont")
        self.search_entry.configure(foreground="#000000")
        self.search_entry.configure(insertbackground="black")
        self.search_entry.bind('<Return>', self.search_event)
        self.search_entry.focus()

        self.search_btn = tk.Button(top)
        self.search_btn.place(relx=0.571, rely=self.yspot, height=24, width=115)
        self.search_btn.configure(activebackground="#ececec")
        self.search_btn.configure(activeforeground="#000000")
        self.search_btn.configure(background="#7cb30e")
        self.search_btn.configure(disabledforeground="#a3a3a3")
        self.search_btn.configure(foreground="white")
        self.search_btn.configure(highlightbackground="#d9d9d9")
        self.search_btn.configure(highlightcolor="black")
        # self.search_btn.configure(pady="15")
        self.search_btn.configure(text='''Αναζήτηση''')
        self.search_btn.configure(relief=RAISED)
        self.search_btn.configure(compound='left')
        self.search_btn.configure(command=lambda: self.search(self.search_data))
        # Κουμπί για άδειασμα παραγγελίων
        self.empty_button = tk.Button(top, text="Αδειασμα παραγγελιών", command=lambda: self.empty_table(),
                                      bg="red", fg="white", bd=3, padx=3, pady=10, state="disabled")

        self.empty_button.place(relx=0.701, rely=self.yspot, height=34, width=180)

        # Κουμπί για διαγραφή παραγγελίων
        self.del_button = tk.Button(top,  bg="red", fg="white", bd=3, padx=3, pady=10, state="disabled")
        self.del_button.configure(pady="0")
        self.del_button.configure(command=self.del_orders)
        self.del_button.configure(text="Διαγραφή παραγγελιών")
        # self.del_button_img = PhotoImage(file="icons/delete_order.png")
        # self.del_button.configure(image=self.del_button_img)
        self.del_button.configure(compound="left")
        self.del_button.configure(state="disabled")

        self.del_button.place(relx=0.880, rely=self.yspot, height=34, width=150)

        global _img0
        _img0 = PhotoImage(file="icons8-search-50.png")
        self.search_btn.configure(image=_img0)

        # ---------------------- Tree -------------------------------
        self.yspot += 0.050
        # self.style.configure('mystyle.Treeview', font="TkDefaultFont")
        self.Scrolledtreeview = ScrolledTreeView(top)
        self.Scrolledtreeview.configure(show="headings", style="mystyle.Treeview", selectmode="extended")
        self.Scrolledtreeview.bind("<Double-1>", self.double_click)
        self.Scrolledtreeview.place(relx=0.015, rely=self.yspot, relheight=0.700, relwidth=0.964)

    # ---------------------Fix -Of- Style------------------------------------

    def fixed_map(self, option):
        # Fix for setting text colour for Tkinter 8.6.9
        # From: https://core.tcl.tk/tk/info/509cafafae
        #
        # Returns the style map for 'option' with any styles starting with
        # ('!disabled', '!selected', ...) filtered out.

        # style.map() returns an empty list for missing options, so this
        # should be future-safe.
        return [elm for elm in self.style.map('Treeview', query_opt=option) if elm[:2] != ('!disabled', '!selected')]

    def update_view(self, table):

        """ Eμφάνησει δεδομέων στο Scrolledtreeview.
        """
        #  Αδιάζουμε πρώτα το tree
        for i in self.Scrolledtreeview.get_children():
            # Εμφάνηση το τι σβήνηει
            # print("DELETED ΑΠΟ ΤΟ TREE ", i)
            self.Scrolledtreeview.delete(i)

        """ 
        Δέχεται τον πίνακα και εμφανίζει τα δεδομένα στο tree
        """

        # width = root.winfo_screenwidth()
        up_conn = sqlite3.connect(dbase)
        up_cursor = up_conn.cursor()
        up_cursor.execute("SELECT * FROM " + table)
        # print("Γραμμη 266: Επιλογή όλων απο τον πίνακα -->>", table)
        self.headers = list(map(lambda x: x[0], up_cursor.description))
        up_data = up_cursor.fetchall()
        up_cursor.close()
        up_conn.close()
        up_index = len(up_data)
        # print("Γραμμη 269: Κεφαλίδες -->> ", headers)
        columns = []
        for head in self.headers:
            columns.append(head)

        self.Scrolledtreeview["columns"] = [head for head in columns]
        for index, head in enumerate(self.headers):
            # ==================================== ΣΤΟΙΧΙΣΗ ΠΕΡΙΕΧΟΜΕΝΩΝ ===========================

            if head == "id" or head == "ID" or head == "Id":
                alignment = "e"
                platos = 1

            elif head == "ΤΙΜΗ":
                alignment = "e"
                platos = int((4 * self.width_of_tree) / 100)

            elif head == "ΣΕΛΙΔΕΣ":
                alignment = "e"
                platos = int((4.8 * self.width_of_tree) / 100)

            elif head == "ΣΥΝΟΛΟ":
                alignment = "e"
                platos = int((5 * self.width_of_tree) / 100)

            elif head == "ΚΩΔΙΚΟΣ":
                alignment = "center"
                platos = int((5 * self.width_of_tree) / 100)

            elif head == "ΤΕΜΑΧΙΑ":
                alignment = "center"
                platos = int((5 * self.width_of_tree) / 100)

            elif head == "ΠΑΡΑΤΗΡΗΣΕΙΣ":
                alignment = "w"
                if len(self.headers) < 10:
                    platos = int((20 * self.width_of_tree) / 100)
                else:
                    platos = int((13 * self.width_of_tree) / 100)

            elif head == "ΠΕΡΙΓΡΑΦΗ":
                alignment = "w"
                if len(self.headers) < 10:
                    platos = int((40 * self.width_of_tree) / 100)
                else:
                    platos = int((30 * self.width_of_tree) / 100)

            elif head == "PARTS_NR":
                alignment = "center"
                platos = int((8 * self.width_of_tree) / 100)

            else:
                alignment = "center"
                platos = int((6.5 * self.width_of_tree) / 100)

            self.Scrolledtreeview.heading(head, text=head, anchor="center",
                                          command=lambda _col=head:
                                          self.sort_by_culumn(self.Scrolledtreeview, _col, False))

            self.Scrolledtreeview.column(head, width=platos, minwidth="30", stretch="1", anchor=alignment)

        colors = ["MAGENTA", "YELLOW", "CYAN", "BLACK", "C/M/Y"]
        self.Scrolledtreeview.tag_configure('oddrow', background='#ece8de', foreground="black", font=("Calibri", 10))
        self.Scrolledtreeview.tag_configure('evenrow', background='white', font=("Calibri", 10))
        self.Scrolledtreeview.tag_configure('oddrowYELLOW', background='#ece8de', foreground="orange",
                                            font=("Calibri", 10, "bold"))
        self.Scrolledtreeview.tag_configure('evenrowYELLOW', background='white', foreground="orange",
                                            font=("Calibri", 10, "bold"))
        self.Scrolledtreeview.tag_configure('oddrowCYAN', background='#ece8de', foreground="blue",
                                            font=("Calibri", 10, "bold"))
        self.Scrolledtreeview.tag_configure('evenrowCYAN', background='white', foreground="blue",
                                            font=("Calibri", 10, "bold"))
        self.Scrolledtreeview.tag_configure('oddrowMAGENTA', background='#ece8de', foreground="magenta",
                                            font=("Calibri", 10, "bold"))
        self.Scrolledtreeview.tag_configure('evenrowMAGENTA', background='white', foreground="magenta",
                                            font=("Calibri", 10, "bold"))
        self.Scrolledtreeview.tag_configure('oddrowBLACK', background="#ece8de", foreground="BLACK",
                                            font=("Calibri", 10, "bold"))
        self.Scrolledtreeview.tag_configure('evenrowBLACK', background="white", foreground="BLACK",
                                            font=("Calibri", 10, "bold"))
        self.Scrolledtreeview.tag_configure("oddrowC/M/Y", background="#ece8de", foreground="#09eb45",
                                            font=("Calibri", 10, "bold"))
        self.Scrolledtreeview.tag_configure("evenrowC/M/Y", background="white", foreground="#09eb45",
                                            font=("Calibri", 10, "bold"))

        for n in range(len(up_data)):
            # Κατασκευή tree το up_index -1 == το τελος ("end")
            try:
                if "ΠΕΡΙΓΡΑΦΗ" in self.headers:
                    # up_data[n][columns.index("ΠΕΡΙΓΡΑΦΗ")] == Ψάχνει όπου είναι η ΚΕΦΑΛΙΔΑ "ΠΕΡΙΓΡΑΦΗ"
                    color = [color for color in colors if color in up_data[n][self.headers.index("ΠΕΡΙΓΡΑΦΗ")]]

                else:
                    # Αν δεν έχει πειργραφή  συνεχίζει
                    color = 0
            except TypeError:
                color = 0
            if int(up_data[n][0]) % 2 == 0 and color:
                # Αν το id διαιρείται με το δυο αλλάζουμε το background

                self.Scrolledtreeview.insert("", up_index - 1, values=up_data[n],
                                             tags=("oddrow" + str(color[0]) if len(color) < 2 else
                                                   "oddrow" + str(color[-1]),))

            elif int(up_data[n][0]) % 2 == 0 and not color:
                self.Scrolledtreeview.insert("", up_index - 1, values=up_data[n], tags=("oddrow",))

            elif int(up_data[n][0]) % 2 != 0 and color:
                self.Scrolledtreeview.insert("", up_index - 1, values=up_data[n],
                                             tags=("evenrow" + str(color[0]) if len(color) < 2 else
                                                   "evenrow" + str(color[-1]),))

            else:
                self.Scrolledtreeview.insert("", up_index - 1, values=up_data[n], tags=("evenrow",))

    def change_color(self, table_name):
        """ Αλλαγή χρώματος κουμπιου όταν το πατάμε
            Δεχεται σαν όρισμα το ονομα του πίνακα που αντιπροσωπευει το κουμπί
            O ελεγχος γίνεται αν το όνομα του πίνακα που πατάμε είναι == με 'text' του κουμπιού
        """
        show_table = ttk.Label(root, background="#7cb30e", foreground="white", text=table_name,
                               font=("Calibri Bold", 10), anchor="center")
        show_table.place(relx=0.100, rely=0.250, relheight=0.030, relwidth=0.100)
        # Αν ο χρήστεις πατήσει στον τελευταίο πίνακα ενεργοποιείτε  το κουμπί
        # Διαφορετικά  απενεργοποιειτε
        if table_name == self.tables[-1]:

            self.empty_button.configure(activebackground="green", activeforeground="white")
            self.empty_button.configure(background="green")
            self.empty_button.configure(state="active")

            self.del_button.configure(background="green", activebackground="green", activeforeground="white")
            self.del_button.configure(state="active")

        else:
            self.empty_button.configure(background="red", state="disabled")
            self.del_button.configure(background="red", state="disabled")

        self.table = table_name  # Ορίζω τον πίνακα που βλεπει ο χρήστης

        lazaros_tables = ["ΦΩΤΟΤΥΠΙΚΑ", "ΤΟΝΕΡ", "ΜΕΛΑΝΑΚΙΑ", "ΧΧΧ", "ΜΕΛΑΝΟΤΑΙΝΙΕΣ"]
        for button in self.buttons:
            btn_text = button.cget('text')
            if table_name == btn_text:  # Το κουμπί που πάτησε ο χρήστης να γίνει το χρωμα του πορτοκαλί
                button.configure(background="#EFA12C")
            elif btn_text in lazaros_tables:
                button.configure(background="#7cb30e")
            else:
                button.configure(background="#657b83")

    # --------------------------------Προσθήκη προιόντος ---------------------------------
    def add_to(self):
        """ Προσθήκη προϊόντος
        """

        if len(self.headers) < 11:
            height = int(root.winfo_screenheight() / 17 * len(self.headers))

        else:
            height = int(root.winfo_screenheight() / 20 * len(self.headers))

        width = int(root.winfo_screenwidth() / 1.5)
        add_window = tk.Toplevel()
        add_window_geometry = str(width) + "x" + str(height) + "+100+100"
        add_window.geometry(add_window_geometry)
        add_window.focus()
        add_window.title("Προσθήκη δεδομένων")
        # Τίτλος παραθύρου
        add_window_title = ttk.Label(add_window, background="orange", foreground="white",
                                     text="Προσθήκη προϊόντος στον πίνακα {}".format(self.table),
                                     font=("Calibri Bold", 15), anchor="center")
        add_window_title.place(relx=0.100, rely=0.001, relheight=0.080, relwidth=0.400)

        # ------------------------------Να πάρουμε τις κεφαλίδες---------------------------
        try:
            conn = sqlite3.connect(dbase)
            cursor = conn.execute("SELECT * FROM " + self.table)
            headers = list(map(lambda x: x[0], cursor.description))

        except sqlite3.OperationalError as error:
            messagebox.showwarning("Σφάλμα.....", "{} \nΠαρακαλώ πρώτα επιλέξτε πίνακα για να κάνετε προσθήκη δεδομένων"
                                   .format(error),
                                   icon='warning')
            add_window.destroy()
            return None

        # ===========================Εμφάνιση κεφαλίδων======================================
        # ΟΙ ΚΕΦΑΛΊΔΕΣ ΕΊΝΑΙ ΤΑ COLUMNS ΤΟΥ ΠΊΝΑΚΑ
        # Nα μετρίσουμε πόσες κεφαλίδες έχει ο πίνακας χωρίς τα " ID " , μας χρειάζεται για τα entry που θα κάνει ο χρήστης
        count_headers = 0
        data_to_add = []
        yspot = 0.080
        for index, header in enumerate(self.headers):
            if header == "ID" or header == "id" or header == "Id":
                continue
            else:
                count_headers += 1
                if len(self.headers) < 10:
                    toner_label = ttk.Label(add_window, text=header, font=("Calibri", 12, "bold"), anchor="se")
                else:
                    toner_label = ttk.Label(add_window, text=header, font=("Calibri", 12, "bold"), anchor="e")
                if len(self.headers) < 9:
                    yspot += 0.080
                    toner_label.place(relx=0.005, rely=yspot, relheight=0.080, relwidth=0.120)
                toner_label.place(relx=0.005, rely=yspot, relheight=0.080, relwidth=0.120)
                yspot += 0.070
                var = StringVar()
                # Εμφάνισει περιγραφής σαν Scrolledtext και όχι σαν απλο Entry
                if header == "ΠΕΡΙΓΡΑΦΗ":
                    perigrafi = ScrolledText(add_window, height=3, border=2)
                    data_to_add.append(perigrafi)
                    if len(self.headers) < 10:
                        perigrafi.place(relx=0.130, rely=yspot, relheight=0.130, relwidth=0.300)
                    perigrafi.place(relx=0.130, rely=yspot - 0.050, relheight=0.130, relwidth=0.300)
                    yspot += 0.080
                else:
                    if len(self.headers) < 10:
                        ttk.Entry(add_window, textvariable=var) \
                            .place(relx=0.130, rely=yspot - 0.045, relheight=0.080, relwidth=0.130)
                    else:
                        ttk.Entry(add_window, textvariable=var) \
                            .place(relx=0.130, rely=yspot - 0.045, relheight=0.040, relwidth=0.130)
                    data_to_add.append(var)

        # ------------------------------------Προσθήκη δεδομένων στην βάση------------------
        def add_to_db():
            culumns = ",".join(self.headers)
            # Να ορίσουμε τα VALUES ΤΗΣ SQL οσα είναι και τα culumns
            # values είναι πόσα ? να έχει ανάλογα τα culumns
            values_var = []

            for head in self.headers:
                if head == "ID" or head == "id" or head == "Id":
                    values_var.append("null")
                else:
                    values_var.append('?')
            values = ",".join(values_var)
            # print("============values_var============line 371", values)
            # print("==========culumns===========", culumns)
            data = []
            for i in range(len(data_to_add)):
                # Ελενχος αν είναι απο το scrolledtext
                # Το scrolledtext θελει get('1.0', 'end-1c') και οχι απλό get
                # Ο Ελεγχος γίνεται με το αν το data_to_add[i] == με class scrolledtext
                # Αν δεν ειναι scrolledtext τότε πέρνουμε τα δεδομένα με το var.get()
                type_of_data_to_add = str(type(data_to_add[i]))
                if "scrolledtext" in type_of_data_to_add:
                    # print("Line 513 Data do add need .get", data_to_add[i].get('1.0', 'end-1c'))
                    data.append(data_to_add[i].get('1.0', 'end-1c'))

                else:
                    data.append(data_to_add[i].get())
            # data = tuple(data_to_add)
            # print("Line 406 data before €", data)

            if "ΣΥΝΟΛΟ" in self.headers:
                # {: 0.2f}           Για εμφάνιση 2 δεκαδικών
                # data[6]= 0 αν ο χρήστης δεν δόσει τιμή να δώσουμε 0 ------data[6] == ΤΙΜΗ
                print("Line 703", headers)
                if data[self.headers.index("ΤΙΜΗ") - 1] == "":
                    data[self.headers.index("ΤΙΜΗ") - 1] = 0
                if data[self.headers.index("ΤΕΜΑΧΙΑ") - 1] == "":
                    data[self.headers.index("ΤΕΜΑΧΙΑ") - 1] = 0
                else:
                    # Μετατροπή , σε . για πολλαπλασιασμό (να βρούμε το σύνολο)
                    data[self.headers.index("ΤΙΜΗ") - 1] = data[self.headers.index("ΤΙΜΗ") - 1].replace(",", ".")
                # Υπολογιστμός ΣΥΝΟΛΟ = ΤΕΜΑΧΙΑ * ΤΙΜΗ

                data[self.headers.index("ΣΥΝΟΛΟ") - 1] = float(data[self.headers.index("ΤΕΜΑΧΙΑ") - 1]) \
                                                         * float(data[self.headers.index("ΤΙΜΗ") - 1])

                data[self.headers.index("ΣΥΝΟΛΟ") - 1] = str(
                    "{:0.2f}".format(data[self.headers.index("ΣΥΝΟΛΟ") - 1])) + "€"
                data[self.headers.index("ΤΙΜΗ") - 1] = str(
                    "{:0.2f}".format(float(data[self.headers.index("ΤΙΜΗ") - 1]))) + " €"
                data[self.headers.index("ΤΕΜΑΧΙΑ") - 1] = str(data[self.headers.index("ΤΕΜΑΧΙΑ") - 1])

            # ================================ Προσθήκη τελευταίας τροποποιησης ============================
            now = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            # Ελεγχος αν ο πίνακας είναι παραγγελίες

            if self.table == self.tables[-1]:
                # Αν ο χρήστης είναι στον πίνακα παραγγελίες τότε προσθέτει την ημερωμηνία αυτόματα
                # now[:10] == ημερωμηνία χωρίς την ώρα
                data[self.headers.index("ΗΜΕΡΩΜΗΝΙΑ") - 1] = now[:10]
                data[-1] = user
            elif len(self.headers) < 7:
                # Αν ο πίνακας έχει λιγότερα απο 7 πεδία τότε βάζει ημερωμηνία και τα σχόλια δεν βαζει χρηστη
                data[-1] = now[:10] + data[-1]
            else:
                # Διαφορετικά βάζει ημερωμηνία χρηστη και σχολια
                data[-1] = now + " " + user + " " + data[-1]
            # print("===========DATA TO ADD AFTER LOOP =========LINE 377 ", data)
            # data_to_add = (toner.get(), model.get(), kodikos.get(),
            #               temaxia.get(), str(timi.get()) + " €", str(timi.get() * temaxia.get()) + " €", selides.get())

            # ΒΑΖΟΥΜΕ ΤΟ ΠΡΩΤΟ NULL ΓΙΑ ΝΑ ΠΆΡΕΙ ΜΟΝΟ ΤΟΥ ΤΟ ID = PRIMARY KEY
            # H ΣΥΝΤΑΞΗ ΕΙΝΑΙ ΑΥΤΉ
            # INSERT INTO table(column1, column2,..)VALUES(value1, value2, ...);  TA  VALUES πρεπει να είναι tuple
            # sql_insert = "INSERT INTO  " + table + "(" + culumns + ")" + "VALUES(NULL, ?, ?, ?, ?, ?, ?, ?);"
            # values είναι πόσα ? να έχει ανάλογα τα culumns
            sql_insert = "INSERT INTO  " + self.table + "(" + culumns + ")" + "VALUES(" + values + ");"
            # print("===============sql_insert==========\n", sql_insert)
            print("===========Προθήκη δεδομένων στο Πίνακα {} Line 483 =========".format(self.table), "\n",
                  self.headers)
            print(data)
            add_to_db_conn = sqlite3.connect(dbase)
            # print("conected ", 50 * ".")
            add_to_db_cursor = add_to_db_conn.cursor()
            # print("cursor done ", 50 * ".")
            add_to_db_cursor.execute(sql_insert, tuple(data))
            # print("sql executed  ", 50 * ".")

            add_to_db_conn.commit()
            # print("ΣΤΗΝ ΒΑΣΗ ΠΡΟΣΤΕΘΗΚΑΝ ", data)
            add_to_db_cursor.close()
            add_to_db_conn.close()
            messagebox.showinfo('Εγινε προσθήκη δεδομένων',
                                "Στην κατηγορία {} Προστέθηκε το {} ".format(self.table, str(data)))
            # Ενημέρωση του tree με τα νέα δεδομένα

            self.update_view(self.table)
            add_window.destroy()
            # print("Εγινε η προσθήκη")
            # print(data)

        # ----------------------------------Κουμπί για να γίνει η προσθήκη-------------------
        enter_button = tk.Button(add_window, text="Προσθήκη", background="green", foreground="White", command=add_to_db)
        if len(self.headers) < 10:
            enter_button.place(relx=0.280, rely=yspot - 0.050, relheight=0.090, relwidth=0.130)
        else:
            enter_button.place(relx=0.130, rely=yspot, relheight=0.050, relwidth=0.130)

        # ΕΞΩΔΟΣ
        def quit_app(event):

            add_window.destroy()

        add_window.bind('<Escape>', quit_app)

    def edit(self):  # Επεξεργασία δεδομένων
        """ Επεξεργασία δεδομένων
        """

        # print("Γραμμη 425: ΕΠΕΞΕΡΓΑΣΙΑ ΣΤΟ Επιλεγμένο id -->", (tree.set(tree.selection(), '#1')))
        if not self.Scrolledtreeview.set(self.Scrolledtreeview.selection(), "#1"):
            messagebox.showwarning("Σφάλμα.....", " Παρακαλώ πρώτα επιλέξτε απο την λίστα για να κάνετε επεξεργασία",
                                   icon='warning')

            return None

        selected_item = (self.Scrolledtreeview.set(self.Scrolledtreeview.selection(), '#1'))
        edit_conn = sqlite3.connect(dbase)
        edit_cursor = edit_conn.cursor()
        edit_cursor.execute("SELECT * FROM " + self.table + " WHERE ID = ?", (selected_item,))
        selected_data = edit_cursor.fetchall()
        selected_data = list(selected_data[0])
        # print("selected_data line 424 ", selected_data)
        # print("headers[0] γραμμή 425 = ", headers[0])
        edit_window = tk.Toplevel()
        if len(self.headers) < 11:
            height = int(root.winfo_screenheight() / 17 * len(self.headers))
        else:
            height = int(root.winfo_screenheight() / 20 * len(self.headers))
        width = int(root.winfo_screenwidth() / 1.5)
        x = "+200"
        y = "+200"
        edit_window_geometry = str(width) + "x" + str(height) + x + y
        edit_window.geometry(edit_window_geometry)
        edit_window.focus()
        edit_window.title("Επεξεργασία δεδομέμων")
        edit_window_title = ttk.Label(edit_window, background="orange", foreground="white",
                                      text="Επεξεργασία δεδομέμων στον πίνακα {}".format(self.table),
                                      font=("Calibri Bold", 15), anchor="center")

        edit_window_title.place(relx=0.100, rely=0.001, relheight=0.080, relwidth=0.500)

        # ===========================Εμφάνιση κεφαλίδων======================================
        data_to_add = []
        colors = ["MAGENTA", "YELLOW", "CYAN", "BLACK", "C/M/Y"]
        yspot = 0.080
        big_entry = ["ΠΕΡΙΓΡΑΦΗ", "ΠΑΡΑΤΗΡΗΣΕΙΣ"]
        for index, header in enumerate(self.headers):
            if header == "ID" or header == "id" or header == "Id":
                continue
            else:
                ton_label = ttk.Label(edit_window, text=header, font=("Calibri", 12, "bold"), anchor="e")
                if len(self.headers) < 9:
                    yspot += 0.050

                ton_label.place(relx=0.005, rely=yspot, relheight=0.080, relwidth=0.120)
                var = StringVar(edit_window, value=selected_data[index])
                # Αν υπάρχει "περιγραφη" στις κεφαλίδες η εμφάνιση των δεδομένων της κεφαλίδας
                # περιγραφή ειναι με scrolltext
                if header == "ΠΕΡΙΓΡΑΦΗ":
                    try:
                        color = [color for color in colors if color in selected_data[self.headers.index("ΠΕΡΙΓΡΑΦΗ")]]
                    except TypeError:
                        print("Line 807 Η περιγραφή δεν μπορει να είναι NoneType")
                        color = 0
                    perigrafi = ScrolledText(edit_window, height=3, border=2)
                    # Αν υπάρχει χρώμα να ελέγχει ποιο χρώμα και ανάλογα να τροποποιεί  το κείμενο
                    if color:
                        if color[0] == "YELLOW":
                            perigrafi.insert('1.0', selected_data[index], "YELLOW")
                            perigrafi.tag_config(color, foreground="orange", font=("Calibri", 10, "bold"))

                        elif len(color) > 1 or "C/M/Y" in color:
                            perigrafi.insert('1.0', selected_data[index], "green")
                            perigrafi.tag_config("green", foreground="#09eb45", font=("Calibri", 10, "bold"))
                        elif color[0] == "CYAN":
                            perigrafi.insert('1.0', selected_data[index], "CYAN")
                            perigrafi.tag_config(color, foreground="blue", font=("Calibri", 10, "bold"))

                        else:
                            perigrafi.insert('1.0', selected_data[index], color)
                            perigrafi.tag_config(color, foreground=color, font=("Calibri", 10, "bold"))

                    else:
                        try:
                            perigrafi.insert('1.0', selected_data[index])
                        except TclError:
                            print("Line 833 Η περιγραφή δεν μπορει να είναι NoneType")
                            perigrafi.insert('1.0', "")

                    if len(self.headers) < 9:
                        yspot += 0.025
                        perigrafi.place(relx=0.130, rely=yspot, relheight=0.130, relwidth=0.400)
                    else:
                        yspot += 0.030
                        perigrafi.place(relx=0.130, rely=yspot, relheight=0.100, relwidth=0.400)

                    data_to_add.append(perigrafi)
                    yspot += 0.030
                else:
                    yspot += 0.020
                    # print("------------ΜΗ ΕΠΕΞΕΡΓΑΣΜΈΝΑ ΔΕΔΟΜΈΝΑ------------", header, var.get())
                    if header not in big_entry:
                        if len(self.headers) < 9:
                            ttk.Entry(edit_window, textvariable=var) \
                                .place(relx=0.130, rely=yspot - 0.010, relheight=0.080, relwidth=0.130)
                        else:
                            ttk.Entry(edit_window, textvariable=var) \
                                .place(relx=0.130, rely=yspot, relheight=0.060, relwidth=0.130)
                    else:
                        if len(self.headers) < 9:
                            ttk.Entry(edit_window, textvariable=var) \
                                .place(relx=0.130, rely=yspot, relheight=0.080, relwidth=0.320)
                        else:
                            ttk.Entry(edit_window, textvariable=var) \
                                .place(relx=0.130, rely=yspot, relheight=0.060, relwidth=0.320)
                    data_to_add.append(var)
                yspot += 0.050

        # --------------------   Προσθήκη δεδομένων στην βάση -------------------------------
        # ---------------------- μετά την επεξεργασία   -------------------------------------

        def update_to_db():
            self.backup()
            print("Γραμμή 733: ---------------ΛΟΓΟΣ BACKUP --->>> ΕΠΕΞΕΡΓΑΣΙΑ ΔΕΔΟΜΕΝΩΝ ------------------------- ")

            # culumns = ",".join(headers)
            # Τα culumns ειναι της μορφής ID, ΤΟΝΕΡ, ΜΟΝΤΕΛΟ, ΚΩΔΙΚΟΣ κτλπ.
            # Πρεπει να γίνουν ΤΟΝΕΡ=?, ΜΟΝΤΕΛΟ=?, ΚΩΔΙΚΟΣ=? κτλπ για την σύνταξη της sql
            # Ευκολο άν μπουν σε νεα λίστα παρά να τροποποιησω την υπάρχουσα λίστα
            edited_culumns = []
            for culumn in self.headers:
                if culumn == "id" or culumn == "ID":
                    continue
                else:
                    edited_culumns.append(culumn + "=?")
            culumns = ",".join(edited_culumns)
            # print("-------------edited_culumns--------------Line 554", edited_culumns)

            # ====================ΕΠΙΛΕΓΜΈΝΟ ID =================
            selected_item = self.Scrolledtreeview.selection()
            selected_id = self.Scrolledtreeview.set(selected_item, "#1")
            # print("==========selected_id==========LINE 469 \n", selected_id)

            # Θα βάζει το data_to_add απο πάνω γραμμη 371
            # βαζουμε και το id που χρειάζεται για το WHERE ID=?
            edited_data = []

            for data in data_to_add:
                type_of_data = str(type(data))
                # Ελεγχος εάν είναι scrolledtext τοτε η προσθήκη θελει (data.get('1.0', 'end-1c')
                # και οχι σκετο data.get()
                # Στο '1.0' το 1 είναι η πρώτη γραμμή  το 0 είναι ο πρώτος χαρακτήρας
                if "scrolledtext" in type_of_data:
                    edited_data.append(data.get('1.0', 'end-1c'))
                else:
                    edited_data.append(data.get())

            # ================================ Προσθήκη τελευταίας τροποποιησης ============================
            # edited_data[-1] ==>> Ειναι η ΠΑΡΑΤΗΡΗΣΗΣ
            now = datetime.now().strftime("%d/%m/%Y %H:%M:%S")

            # Αν ο πίνακας είναι ο τελευταίος δλδ παραγγελιων να εισάγει μόνο τον χρήστη
            if self.table == self.tables[-1]:
                edited_data[-1] = user
            # Aν ο πίνακας εχει περισσοτερα απο 7 κεφαλίδες τότε στο "ΠΑΡΑΤΗΡΗΣΕΙΣ" να βάλει μόνο ημερωμηνία και χρήστη
            elif len(edited_culumns) > 7:
                edited_data[-1] = now + " " + user
            # Διαφορετικά να βάλει μόνο ημερωμηνία όχι ώρα και ότι γράφει ο χρήστης
            else:
                edited_data[-1] = now[:10] + "  " + data_to_add[-1].get()
            # print("Line 772", edited_data[-1][0:-1])
            # ================================= Προσθήκη id =================================================
            edited_data.append(selected_id)
            # print("Line 573 Edited data ", edited_data)
            # ====================================== ΑΥΤΟΜΑΤΗ ΕΝΗΜΕΡΩΣΗ ΣΥΝΟΛΟΥ =============================
            # ======================================= ΚΑΙ ΠΡΟΣΘΗΚΗ ΣΥΜΒΟΛΟΥ €    =============================
            if "ΣΥΝΟΛΟ=?" in edited_culumns:
                try:
                    # edited_data[6] == τιμή
                    edited_data[edited_culumns.index("ΤΙΜΗ=?")] = \
                        edited_data[edited_culumns.index("ΤΙΜΗ=?")].replace(",",
                                                                            ".")  # Μετατροπή , σε . για πολλαπλασιασμό

                    # Αν ο χρήστης δεν βάλει τεμάχειο να γίνει αυτόματα 0
                    if edited_data[edited_culumns.index("ΤΕΜΑΧΙΑ=?")] == "":
                        edited_data[edited_culumns.index("ΤΕΜΑΧΙΑ=?")] = "0"
                        # print("Line 604 edited_data[5] ", edited_data[5])

                    else:
                        pass
                    # Αν ο χρήστης δεν ορίσει τιμή να γίνει αυτόματα 0
                    if edited_data[edited_culumns.index("ΤΙΜΗ=?")] == "":
                        edited_data[
                            edited_culumns.index("ΤΙΜΗ=?")] = "0"  # 0 σε string γιατί ψάχνουμε αν έχει το € μέσα
                        # print("Line 610 edited_data[6] ", edited_data[6])

                    else:
                        pass
                    # {:0.2f} Για να εμφανίνζει την τιμή με 2 δεκαδικά πίσω απο την τιμή 10.00 € και οχι 10 €

                    if "€" in edited_data[edited_culumns.index("ΤΙΜΗ=?")]:
                        edited_data[edited_culumns.index("ΣΥΝΟΛΟ=?")] = \
                            str("{:0.2f}".format(float(edited_data[edited_culumns.index("ΤΙΜΗ=?")][:-1]) *
                                                 float(edited_data[edited_culumns.index("ΤΕΜΑΧΙΑ=?")]))) + " €"
                        edited_data[edited_culumns.index("ΤΕΜΑΧΙΑ=?")] = str(
                            edited_data[edited_culumns.index("ΤΕΜΑΧΙΑ=?")])

                    else:
                        edited_data[edited_culumns.index("ΣΥΝΟΛΟ=?")] = \
                            str("{:0.2f}".format(float(edited_data[edited_culumns.index("ΤΙΜΗ=?")]) *
                                                 float(edited_data[edited_culumns.index("ΤΕΜΑΧΙΑ=?")]))) + " €"
                        edited_data[edited_culumns.index("ΤΕΜΑΧΙΑ=?")] = str(
                            edited_data[edited_culumns.index("ΤΕΜΑΧΙΑ=?")])

                    if "€" not in str(edited_data[edited_culumns.index("ΤΙΜΗ=?")]):
                        edited_data[edited_culumns.index("ΤΙΜΗ=?")] = \
                            str("{:0.2f}".format(float(edited_data[edited_culumns.index("ΤΙΜΗ=?")]))) + " €"

                    else:
                        edited_data[edited_culumns.index("ΤΙΜΗ=?")] = \
                            str("{:0.2f}".format(float(edited_data[edited_culumns.index("ΤΙΜΗ=?")][:-1]))) + " €"

                except ValueError as error:
                    messagebox.showwarning('ΠΡΟΣΟΧΉ ...',
                                           "Σφάλμα {} \n1)Ο Πίνακας {} δεν είναι σωστός".format(error, self.table))
                    print("Line 827 Σφάλμα {} \n1)Ο Πίνακας {} δεν είναι σωστός".format(error, self.table))

                    edit_window.destroy()
                    return None
            else:
                pass
            # print("Γραμμη 491:  ----------- ΕΠΕΞΕΡΓΑΣΜΈΝΑ ΔΕΔΟΜΈΝΑ------------", tuple(edited_data))
            # H ΣΥΝΤΑΞΗ ΕΙΝΑΙ ΑΥΤΉ
            # sql_insert = "INSERT INTO  " + table + "(" + culumns + ")" + "VALUES(NULL, ?, ?, ?, ?, ?, ?, ?);"
            # sqlite_update_query = """Update new_developers set salary = ?, email = ? where id = ?"""
            edit_cursor.execute("UPDATE " + self.table + "  SET " + culumns + " WHERE ID=? ", (tuple(edited_data)))

            edit_conn.commit()
            print(60 * "*")
            print(50 * "*", "Το προΐον ενημερώθηκε με επιτυχία", 50 * "*")
            print(60 * "*")
            print("Γραμμη 580 Παλιά δεδομένα στον πίνακα ==> {}".format(self.table), "\n", self.headers[1:], "\n",
                  selected_data[1:])
            print("Γραμμη 581 Νέα δεδομένα στον πίνακα ==>{}".format(self.table), "\n", self.headers[1:], "\n",
                  edited_data[:-1])

            # Ενημέρωση του tree με τα νέα δεδομένα

            self.update_view(self.table)
            edit_window.destroy()
            # print("Γραμμη 510: Εγινε η Ενημέρωση του tree ")
            # print(data_to_add)

            # ΕΞΩΔΟΣ

        def quit_app(event):

            edit_window.destroy()

        yspot += 0.050
        edit_window.bind('<Escape>', quit_app)
        update_button = tk.Button(edit_window, command=update_to_db, text="Ενημέρωση προϊόντος", background="red",
                                  foreground="white", border=3, anchor="center")
        update_button.place(relx=0.160, rely=yspot, relheight=0.090, relwidth=0.140)

        # Πρέπει να κάνω το add_to_orders() συνάρτιση για τις παραγγελίες
        # print("Line 909 data to orders", selected_data)
        if self.table != tables[-1] and "ΚΩΔΙΚΟΣ" in self.headers and "ΠΕΡΙΓΡΑΦΗ" in self.headers:
            order_button = tk.Button(edit_window, command=lambda: self.add_to_orders(edit_window, selected_data),
                                     text="Προσθήκη στις παραγγελίες", bg="blue", fg="white", bd=3)
            order_button.place(relx=0.340, rely=yspot, relheight=0.090, relwidth=0.160)

    def backup(self):

        def progress(status, remainig, total):
            print(f"{status} Αντιγράφηκαν {total - remainig} απο {total} σελίδες...")

        try:
            now = datetime.now().strftime("%d %m %Y %H %M %S")
            today = datetime.today().strftime("%d %m %Y")
            back_dir = "backups" + "\\" + today + "\\"

            backup_file = os.path.join(back_dir, os.path.basename(dbase[:-3]) + " " + now + ".db")
            # print("============BACKUP FILE===========Line 542=\n", backup_file, "\n")
            if not os.path.exists(back_dir):
                os.makedirs(back_dir)
            else:
                pass
            # Υπάρχουσα βάση
            conn = sqlite3.connect(dbase)
            print("===========Υπάρχουσα βάση===========Line 744\n ", dbase, "\n")

            # Δημιουργία νέας βάσης και αντίγραφο ασφαλείας
            back_conn = sqlite3.connect(backup_file)
            with back_conn:
                conn.backup(back_conn, pages=10, progress=progress)
                back_conn.close()
                text = "Η βάση αντιγράφηκε :  "
                result = text + os.path.realpath(backup_file)
                # print("=====Αποτέλεσμα ====Line 558\n", result)
                # Ειναι ενοχλητικο να εμφανιζει καθε φορα μηνυμα οτι εγινε backup
                # tkinter.messagebox.showinfo('Αποτέλεσμα αντιγράφου ασφαλείας', result)
        except FileNotFoundError as file_error:
            messagebox.showwarning("Σφάλμα...", "{}".format(file_error))
            print("File Error Line 641", file_error)

        except sqlite3.Error as error:
            if not os.path.exists(backup_file):
                result = "Σφάλμα κατα την αντιγραφή : ", error
                messagebox.showwarning("Σφάλμα...", "{}".format(result))
        finally:
            try:
                if back_conn:
                    back_conn.close()
                    print("Δημιουργία αντιγράφου ασφαλείας στο αρχείο  ", backup_file, " ολοκληρώθηκε")
            except UnboundLocalError as error:
                print(f"Η σύνδεση με {backup_file} δεν έγινε ποτέ Line 1074 {error}")
                messagebox.showinfo(f"Η σύνδεση με {backup_file} δεν έγινε ποτέ Line 1075 {error}")

    # ========================================================================================
    # ------------------------------------- ΠΡΟΣΘΗΚΗ ΠΑΡΑΓΓΕΛΙΑΣ ----------------------------=
    # -----------------------****************** ΠΡΟΣΟΧΗ ************-------------------------=
    # Οι παραγγελίες γίνονται στον τελευταίο πίνακα της βάσης δεδωμένων ---------------------=
    # ========================================================================================
    # Δεχεται σαν όρισμα το edit_windows για να μπορέσουμε να το κλείσουμε όταν κάνουμε την προσθήκη παραγγελίας
    def add_to_orders(self, edit_window, data_to_add):
        # Προσθήκη κωδικού και περιγραφής στις παραγγελίες
        code_for_order = data_to_add[self.headers.index("ΚΩΔΙΚΟΣ")]
        if not code_for_order:
            answer = messagebox.askquestion("ΠΡΟΣΟΧΗ",
                                            "Το προϊόν δεν εχει κωδικό θέλετε να το  προσθέσετε;", icon='warning')
            if answer == 'yes':
                pass
            else:
                # messagebox.showwarning("ΑΚΥΡΩΣΗ", "Το προϊόν δεν προστέθηκε στις παραγγελίες")
                edit_window.destroy()
                return None
        perigrafi_for_order = data_to_add[self.headers.index("ΠΕΡΙΓΡΑΦΗ")]
        now = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        # code_for_order == κωδικός προϊόντος
        # now[:10] == μόνο ημερομηνία όχι ώρα
        # perigrafi_for_order == περιγραφή του προϊόντος
        # "" == κενό για να βάζει χ στο πεδίο αποτέλεσμα αν το παρήγγειλε ή όχι
        # user == ο χρήστης του υπολογιστή
        data_to_orders = [code_for_order, now[:10], perigrafi_for_order, "", user]

        order_conn = sqlite3.connect(dbase)
        order_cursos = order_conn.cursor()
        order_cursos.execute("SELECT * FROM " + tables[-1] + ";")

        headers_of_orders = list(map(lambda x: x[0], order_cursos.description))
        culumns = ",".join(headers_of_orders)

        values_var = []
        for head in headers_of_orders:
            if head == "ID" or head == "id" or head == "Id":
                values_var.append("null")
            else:
                values_var.append('?')
        values = ",".join(values_var)

        data_from_paraggelies = order_cursos.fetchall()
        found = False
        for data in data_from_paraggelies:
            if code_for_order != "" and code_for_order in data:
                found = True  # Δηλαδή βρεθηκε ο κωδικός στις παραγγελίες
                answer = messagebox.askquestion("ΠΡΟΣΟΧΗ",
                                                " Ο κωδικός {} υπαρχει ήδη στης παραγγελίες, "
                                                "θέλετε να το ξανα προσθέσετε;".format(code_for_order),
                                                icon='warning')
                # Αν ο χρήστης θέλει να το ξαναπροσθέσει
                if answer == "yes":
                    sql_insert = "INSERT INTO " + self.tables[-1] + "(" + culumns + ")" + "VALUES(" + values + ");"
                    order_cursos.execute(sql_insert, tuple(data_to_orders))
                    order_conn.commit()
                    order_cursos.close()
                    order_conn.close()
                    messagebox.showwarning("ΠΡΟΣΘΗΚΗ",
                                           "Ο κωδικός {} προστέθηκε στις παραγγελίες".format(code_for_order))
                    edit_window.destroy()
                    self.update_view(self.table)
                    return None
                else:
                    messagebox.showwarning("ΑΚΥΡΩΣΗ",
                                           "Ο κωδικός {} δεν προστέθηκε στις παραγγελίες".format(code_for_order))
                    edit_window.destroy()

                    return None
            else:
                found = False  # Δεν βρέθηκε ο κωδικός στις παραγγελίες

        # Αν δεν βρέθηκε στις παραγγελίες και υπάρχουν παραγγελίες
        if not found and data_from_paraggelies:
            order_conn = sqlite3.connect(dbase)
            order_cursos = order_conn.cursor()
            sql_insert = "INSERT INTO " + self.tables[-1] + "(" + culumns + ")" + "VALUES(" + values + ");"
            order_cursos.execute(sql_insert, tuple(data_to_orders))
            order_conn.commit()
            order_cursos.close()
            order_conn.close()
            messagebox.showwarning("ΠΡΟΣΘΗΚΗ", "Ο κωδικός {} προστέθηκε στις παραγγελίες".format(code_for_order))
            edit_window.destroy()
            self.update_view(self.table)
            return None
        # Αν δεν υπάρχουν παραγγελίες
        if not data_from_paraggelies:
            try:
                sql_insert = "INSERT INTO " + self.tables[-1] + "(" + culumns + ")" + "VALUES(" + values + ");"
                order_cursos.execute(sql_insert, tuple(data_to_orders))
                order_conn.commit()
                order_cursos.close()
                order_conn.close()
                messagebox.showwarning("ΠΡΟΣΘΗΚΗ", "Ο κωδικός {} προστέθηκε στις παραγγελίες".format(code_for_order))
                edit_window.destroy()
                self.update_view(self.table)
                return None
            except sqlite3.ProgrammingError as error:
                print("Σφάλμα. Line 768..sqlite3.ProgrammingError {}".format(error))
                messagebox.showwarning("Σφάλμα...", "Line 768..sqlite3.ProgrammingError {} ".format(error))
                edit_window.destroy()
                self.update_view(self.table)
                return None
        else:
            return None

    # ================================Συνάρτηση για διαγραφή  =================
    def del_from_tree(self):
        selected_item = (self.Scrolledtreeview.set(self.Scrolledtreeview.selection(), '#1'))

        del_conn = sqlite3.connect(dbase)
        del_cursor = del_conn.cursor()
        del_cursor.execute("SELECT * FROM " + self.table + " WHERE ID = ?", (selected_item,))
        selected_data = del_cursor.fetchall()
        selected_data = list(selected_data[0])
        print("Γραμμη 787: Επιλεγμένα για διαγραφή δεδομένα -->>", self.headers, selected_data)

        # ======================ΕΠΙΒΕΒΑΙΩΣΗ ΔΙΑΓΡΑΦΗΣ============
        answer = messagebox.askquestion("Θα πραγματοποιηθεί διαγραφή!",
                                        " Είστε σήγουρος για την διαγραφή του {};".format(selected_data),
                                        icon='warning')
        # print('Γραμμή 792: ========ΔΙΑΓΡΑΦΗ=============', "Το {} επιλέχθηκε για διαγαφή !".format(selected_data))
        if answer == 'yes':
            messagebox.showwarning('Διαγραφή...', "Το {} διαγράφηκε!".format(selected_data))
            # Αν ο χρήστης επιλεξει το "yes" παει στην γραμμή 804 ==>> del_cursor.execute("DEL............

            pass
        else:
            messagebox.showinfo('Ακύρωση διαγραφής', " Τίποτα δεν διαγράφηκε  ")
            print("Γραμμή 604: =================ΑΚΥΡΟΣΗ ΔΙΑΓΡΑΦΗΣ===============\n", selected_data)
            print()
            return None
        print("Γραμμή 778: ---------------ΛΟΓΟΣ BACKUP --->>> ΔΙΑΓΡΑΦΗ ΔΕΔΟΜΕΝΩΝ ------------------------- ")
        self.backup()
        del_cursor.execute("DELETE FROM " + self.table + " WHERE ID=?", (selected_item,))
        del_conn.commit()
        del_conn.close()
        print()
        print("Γραμμη 789:===============ΠΡΑΓΜΑΤΟΠΟΙΗΘΗΚΕ ΔΙΑΓΡΑΦΉ ΤΟΥ===============\n", self.headers, selected_data)
        print()

        try:
            self.Scrolledtreeview.delete(self.Scrolledtreeview.selection())
            # print("======ΕΓΙΝΕ ΔΙΑΓΡΑΦΗ ΑΠΟ ΤΟ TREE====================================line 600 ")
            return selected_item
        except TclError as error:
            print("ΣΦΑΛΜΑ Line 1206", error)

    # =====================================ΑΝΑΖΗΤΗΣΗ=========================================
    def search(self, search_data):
        """
        Αναζήτηση σε πίνακα για δεδομένω
        :param search_data:
        :return: None
        """
        if search_data.get() != "":  # Αν έχουμε γράψει κάτι στην αναζήτηση στο search_entry
            # Αδειάζουμε το tree  δλδ το self.Scrolledtreeview
            self.Scrolledtreeview.delete(*self.Scrolledtreeview.get_children())
            # Σύνδεση με βάση
            search_conn = sqlite3.connect(dbase)
            search_cursor = search_conn.cursor()
            # idea = SELECT * FROM tablename WHERE name or email or address or designation = 'nagar';
            search_headers = []
            no_neded_headers = ["id", "ID", "Id"]
            operators = []
            for header in self.headers:
                if header not in no_neded_headers:
                    search_headers.append(header + " LIKE ?")
                    operators.append('%' + str(search_data.get()) + '%')
            search_headers = " OR ".join(search_headers)

            # ΕΤΑΙΡΕΙΑ LIKE ? OR ΜΟΝΤΕΛΟ LIKE ? OR ΚΩΔΙΚΟΣ LIKE ? OR TEMAXIA LIKE ? OR ΤΙΜΗ LIKE ? etc...

            # search_cursor.execute("SELECT * FROM " + table + " WHERE \
            # ΤΟΝΕΡ LIKE ? OR ΜΟΝΤΕΛΟ LIKE ? OR ΚΩΔΙΚΟΣ LIKE ? OR TEMAXIA LIKE ? OR ΤΙΜΗ LIKE ? etc...
            # ('%' + str(search_data.get()) + '%', '%' + str(search_data.get()) + '%', '%' + str(search_data.get())...

            search_cursor.execute("SELECT * FROM " + self.table + " WHERE " + search_headers, operators)
            fetch = search_cursor.fetchall()

            colors = ["MAGENTA", "YELLOW", "CYAN", "BLACK", "C/M/Y"]
            self.Scrolledtreeview.tag_configure('oddrow', background='#ece8de', foreground="black",
                                                font=("Calibri", 10))
            self.Scrolledtreeview.tag_configure('evenrow', background='white', font=("Calibri", 10))
            self.Scrolledtreeview.tag_configure('oddrowYELLOW', background='#ece8de', foreground="orange",
                                                font=("Calibri", 10, "bold"))
            self.Scrolledtreeview.tag_configure('evenrowYELLOW', background='white', foreground="orange",
                                                font=("Calibri", 10, "bold"))
            self.Scrolledtreeview.tag_configure('oddrowCYAN', background='#ece8de', foreground="blue",
                                                font=("Calibri", 10, "bold"))
            self.Scrolledtreeview.tag_configure('evenrowCYAN', background='white', foreground="blue",
                                                font=("Calibri", 10, "bold"))
            self.Scrolledtreeview.tag_configure('oddrowMAGENTA', background='#ece8de', foreground="magenta",
                                                font=("Calibri", 10, "bold"))
            self.Scrolledtreeview.tag_configure('evenrowMAGENTA', background='white', foreground="magenta",
                                                font=("Calibri", 10, "bold"))
            self.Scrolledtreeview.tag_configure('oddrowBLACK', background="#ece8de", foreground="BLACK",
                                                font=("Calibri", 10, "bold"))
            self.Scrolledtreeview.tag_configure('evenrowBLACK', background="white", foreground="BLACK",
                                                font=("Calibri", 10, "bold"))
            self.Scrolledtreeview.tag_configure("oddrowC/M/Y", background="#ece8de", foreground="#09eb45",
                                                font=("Calibri", 10, "bold"))
            self.Scrolledtreeview.tag_configure("evenrowC/M/Y", background="white", foreground="#09eb45",
                                                font=("Calibri", 10, "bold"))
            odd_or_even = 0
            for data in fetch:
                # Κάνει αναζήτηση του color μόνο στην κεφαλίδα "ΠΕΡΙΓΡΑΦΗ"
                color = [color for color in colors if color in data[self.headers.index("ΠΕΡΙΓΡΑΦΗ")]]
                # color = [color for color in colors if color in data[4]]  # up_data[n][4] == ΠΕΡΙΓΡΑΦΗ
                odd_or_even += 1
                if odd_or_even % 2 == 0 and color:
                    self.Scrolledtreeview.insert("", "end", values=data,
                                                 tags=(
                                                 "oddrow" + color[0] if len(color) < 2 else "oddrow" + color[-1],))

                elif odd_or_even % 2 == 0 and not color:
                    self.Scrolledtreeview.insert("", "end", values=data, tags=("oddrow",))

                elif odd_or_even % 2 != 0 and color:
                    self.Scrolledtreeview.insert("", "end", values=data,
                                                 tags=(
                                                 "evenrow" + color[0] if len(color) < 2 else "evenrow" + color[-1],))
                else:
                    self.Scrolledtreeview.insert("", 'end', values=data, tags=("evenrow",))

            search_cursor.close()
            search_conn.close()

    # ----------------------------------Συντομέυσεις --------------------------------------
    # ==================================Πληκτολόγιο=====================
    # ΠΡΟΣΘΗΚΗ
    def add_event(self, event):
        self.add_to()

    def double_click(self, event):
        self.edit()

    def search_event(self, event):  # Συντόμευση αναζήτησεις
        """ Οταν πατάμε enter στην αναζήτηση να εκτελεστεί το search(search_data)
        """
        self.search(self.search_data)

    # --------------------- Ταξινόμηση ---------------------------------------
    def sort_by_culumn(self, tree, column, reverse):
        """ Ταξινομηση δεδομένων πατώντας στις κεφαλίδες τou tree
            tree == self.Scrolledtreeview
            column = κεφαλίδα του tree
        """

        lista = [[self.Scrolledtreeview.set(k, column), k] for k in tree.get_children("")]
        """ lista = [[κατι, id],[κατι αλλο , id]]  έχει όλα τα δεδομένω του πεδίου που πατάει ο χρήστης
        """
        try:
            # sorted(iterable, *, key=None, reverse=False)
            # Return a new sorted list from the items in iterable.
            if column == "ΤΙΜΗ" or column == "ΣΥΝΟΛΟ" or column == "ΚΩΔΙΚΟΣ" or column == "ΣΕΛΙΔΕΣ":
                # Αν Αληθής γίνεται  Αφαίρεση € , "" και None για να γίνει sort σαν αριθμοί
                for index, (x, y) in enumerate(lista):
                    # Tο y δεν μας χρειάζεται αλλά είναι το id στο lista = [[κατι, id],[κατι αλλο , id]]
                    # ισως θα μπορούσε να γίνει και x = x.replace("€", "")
                    # το lista[index][0] ειναι το x δηλαδη τα δεδομενα στο lista = [[κατι, id],[κατι αλλο , id]]
                    lista[index][0] = lista[index][0].replace("€", "")  # Αφαίρεση €

                    lista[index][0] = lista[index][0].replace(",", ".")  # Αφαίρεση ,
                    if lista[index][0] == "":  # Αφαίρεση "" αν είναι κενό δλδ
                        lista[index][0] = 0.00
                    if lista[index][0] == 'None':  # Αφαίρεση  αν είναι 'None'
                        lista[index][0] = 0        # Αντικατάσταση με 0

            lista = sorted(lista, key=lambda x: float(x[0]), reverse=reverse)  # Ταξινόμηση για τιμές και σύνολα
        except ValueError as error:  # Αν δεν είναι αριθμοί βγάζει error για το float και το κάνει με το lista.sort()
            print("Σφάλμα στην ταξηνόμιση γραμμη 1424 ", error)
            lista = sorted(lista, reverse=reverse)

        # Εμφάνισει στο tree την ταξινομημένη lista
        for index, (val, k) in enumerate(lista):
            tree.move(k, "", index)

        tree.heading(column, command=lambda: self.sort_by_culumn(tree, column, not reverse))

    # -----------------------------  Αδειασμα παραγγελιών  -------------------------------------------
    # ------------------Προσοχή διαγραφή του τελευταίου πίνακα (με αλφαβητική σειρά)------------------
    def empty_table(self):
        self.backup()
        print("Λογος αντιγράφου ασφαλείας ==>> διαγραφή πίνακα {}".format(self.tables[-1]))
        answer = messagebox.askquestion("ΠΡΟΣΟΧΗ", "Θα πραγματοποιηθεί διαγραφή του πίνακα {}, \
                                                    Είστε σήγουρος για την διαγραφή του; ".format(self.tables[-1]),
                                        icon='warning')
        if answer == 'yes':
            empty_conn = sqlite3.connect(dbase)
            empty_cursor = empty_conn.cursor()
            empty_cursor.execute("SELECT * FROM " + self.tables[-1] + ";")
            paraggelies = empty_cursor.fetchall()
            print("===============Παραγγελίες διαγράφικαν απο χρήστη {} ========".format(user))
            for paraggelia in paraggelies:
                print(paraggelia)
            empty_cursor.execute("DELETE FROM " + self.tables[-1] + ";")
            empty_conn.commit()
            empty_cursor.execute("""VACUUM;""")
            empty_cursor.close()
            empty_conn.close()
            messagebox.showwarning("ΠΡΟΣΟΧΗ ", "Ο πίνακας {} άδειασε".format(self.tables[-1]))
            self.update_view(self.table)

        else:
            print('Ακύρωση διαγραφής παραγγελιών', " Τίποτα δεν διαγράφηκε  ")
            messagebox.showinfo('Ακύρωση διαγραφής παραγγελιών', " Τίποτα δεν διαγράφηκε  ")

            return None

# -----------------------------  Αδειασμα μόνο επιλεγμένων παραγγελιών   -------------------------------------------
    # ------------------Προσοχή διαγραφή του τελευταίου πίνακα (με αλφαβητική σειρά)------------------
    def del_orders(self):
        self.backup()
        id_orders_to_del = []
        codes_of_orders = []
        orders = []
        selected_item = self.Scrolledtreeview.selection()

        for item in selected_item:
            # info ==> Dictionary  {'ID': '89', 'ΚΩΔΙΚΟΣ': '19002', 'ΗΜΕΡΩΜΗΝΙΑ': '31/12/2019', }
            info = self.Scrolledtreeview.set(item)
            orders.append(info)  # Ολες οι πληροφορίες της παραγγελίας
            codes_of_orders.append(info['ΚΩΔΙΚΟΣ'])  # Πέρνουμε μόνο το value απο το key 'ΚΩΔΙΚΟΣ'
            id_orders_to_del.append(info['ID'])  # Πέρνουμε μόνο το value απο το key 'ID'

        print("Λογος αντιγράφου ασφαλείας ==>> Διαγραφή παραγγελιών απο τον πίνακα {}".format(self.tables[-1]))
        answer = messagebox.askquestion("ΠΡΟΣΟΧΗ", "Θα πραγματοποιηθεί διαγραφή των κωδικών  {}, "
                                                   "\nΕίστε σήγουρος για την διαγραφή τους; ".format(codes_of_orders),
                                        icon='warning')
        if answer == 'yes':
            empty_conn = sqlite3.connect(dbase)
            empty_cursor = empty_conn.cursor()
            for order_id in id_orders_to_del:
                empty_cursor.execute("DELETE FROM " + self.tables[-1] + " WHERE ID =?", (order_id,))

            print("===============Παραγγελίες διαγράφικαν απο χρήστη {} ========".format(user))
            for order in orders:
                print(order)

            empty_conn.commit()
            empty_cursor.execute("""VACUUM;""")
            empty_cursor.close()
            empty_conn.close()
            messagebox.showwarning("ΠΡΟΣΟΧΗ ", "Οι κωδικοί \n {} διαγράφικαν".format(codes_of_orders))
            self.update_view(self.table)

        else:
            print('Ακύρωση διαγραφής παραγγελιών', " Τίποτα δεν διαγράφηκε  ")
            messagebox.showinfo('Ακύρωση διαγραφής παραγγελιών', " Τίποτα δεν διαγράφηκε  ")

            return None

# The following code is added to facilitate the Scrolled widgets you specified.
class AutoScroll(object):
    """Configure the scrollbars for a widget."""

    def __init__(self, master):
        #  Rozen. Added the try-except clauses so that this class
        #  could be used for scrolled entry widget for which vertical
        #  scrolling is not supported. 5/7/14.
        try:
            vsb = ttk.Scrollbar(master, orient='vertical', command=self.yview)
        except:
            pass
        hsb = ttk.Scrollbar(master, orient='horizontal', command=self.xview)

        # self.configure(yscrollcommand=_autoscroll(vsb),
        #    xscrollcommand=_autoscroll(hsb))
        try:
            self.configure(yscrollcommand=self._autoscroll(vsb))
        except:
            pass
        self.configure(xscrollcommand=self._autoscroll(hsb))

        self.grid(column=0, row=0, sticky='nsew')
        try:
            vsb.grid(column=1, row=0, sticky='ns')
        except:
            pass
        hsb.grid(column=0, row=1, sticky='ew')

        master.grid_columnconfigure(0, weight=1)
        master.grid_rowconfigure(0, weight=1)

        # Copy geometry methods of master  (taken from ScrolledText.py)
        if py3:
            methods = tk.Pack.__dict__.keys() | tk.Grid.__dict__.keys() \
                      | tk.Place.__dict__.keys()
        else:
            methods = tk.Pack.__dict__.keys() + tk.Grid.__dict__.keys() \
                      + tk.Place.__dict__.keys()

        for meth in methods:
            if meth[0] != '_' and meth not in ('config', 'configure'):
                setattr(self, meth, getattr(master, meth))

    @staticmethod
    def _autoscroll(sbar):
        """Hide and show scrollbar as needed."""

        def wrapped(first, last):
            first, last = float(first), float(last)
            if first <= 0 and last >= 1:
                sbar.grid_remove()
            else:
                sbar.grid()
            sbar.set(first, last)

        return wrapped

    def __str__(self):
        return str(self.master)


def _create_container(func):
    """Creates a ttk Frame with a given master, and use this new frame to
    place the scrollbars and the widget."""

    def wrapped(cls, master, **kw):
        container = ttk.Frame(master)
        container.bind('<Enter>', lambda e: _bound_to_mousewheel(e, container))
        container.bind('<Leave>', lambda e: _unbound_to_mousewheel(e, container))
        return func(cls, container, **kw)

    return wrapped


class ScrolledTreeView(AutoScroll, ttk.Treeview):
    """A standard ttk Treeview widget with scrollbars that will
    automatically show/hide as needed."""

    @_create_container
    def __init__(self, master, **kw):
        ttk.Treeview.__init__(self, master, **kw)
        AutoScroll.__init__(self, master)


def _bound_to_mousewheel(event, widget):
    child = widget.winfo_children()[0]
    if platform.system() == 'Windows' or platform.system() == 'Darwin':
        child.bind_all('<MouseWheel>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Shift-MouseWheel>', lambda e: _on_shiftmouse(e, child))
    else:
        child.bind_all('<Button-4>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Button-5>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Shift-Button-4>', lambda e: _on_shiftmouse(e, child))
        child.bind_all('<Shift-Button-5>', lambda e: _on_shiftmouse(e, child))


def _unbound_to_mousewheel(event, widget):
    if platform.system() == 'Windows' or platform.system() == 'Darwin':
        widget.unbind_all('<MouseWheel>')
        widget.unbind_all('<Shift-MouseWheel>')
    else:
        widget.unbind_all('<Button-4>')
        widget.unbind_all('<Button-5>')
        widget.unbind_all('<Shift-Button-4>')
        widget.unbind_all('<Shift-Button-5>')


def _on_mousewheel(event, widget):
    if platform.system() == 'Windows':
        widget.yview_scroll(-1 * int(event.delta / 120), 'units')
    elif platform.system() == 'Darwin':
        widget.yview_scroll(-1 * int(event.delta), 'units')
    else:
        if event.num == 4:
            widget.yview_scroll(-1, 'units')
        elif event.num == 5:
            widget.yview_scroll(1, 'units')


def _on_shiftmouse(event, widget):
    if platform.system() == 'Windows':
        widget.xview_scroll(-1 * int(event.delta / 120), 'units')
    elif platform.system() == 'Darwin':
        widget.xview_scroll(-1 * int(event.delta), 'units')
    else:
        if event.num == 4:
            widget.xview_scroll(-1, 'units')
        elif event.num == 5:
            widget.xview_scroll(1, 'units')


if __name__ == '__main__':
    vp_start_gui()
